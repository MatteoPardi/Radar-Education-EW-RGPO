<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inganno Radar - Guerra Elettronica</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            overflow: hidden;
        }

        .presentation-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            padding: 60px;
            background: linear-gradient(180deg, #0a0e27 0%, #050810 50%, #0a0e27 100%);
        }

        .slide.active {
            display: flex;
            flex-direction: column;
        }

        .slide-title {
            font-size: 3.5em;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 30px;
            text-align: center;
        }

        .slide-subtitle {
            font-size: 1.8em;
            color: #00ff88;
            text-align: center;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #00ff88;
        }

        .slide-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }

        .bullet-points {
            list-style: none;
            font-size: 1.5em;
            line-height: 1.8;
            color: #e0e0e0;
            max-width: 800px;
        }

        .bullet-points li {
            margin: 20px 0;
            padding-left: 30px;
            position: relative;
        }

        .bullet-points li::before {
            content: "▸";
            position: absolute;
            left: 0;
            color: #00ff88;
            font-size: 1.2em;
            text-shadow: 0 0 10px #00ff88;
        }

        .visual-area {
            width: 100%;
            height: 100%;
            position: relative;
            flex: 1;
        }

        /* Radar station */
        .radar-station {
            position: absolute;
            bottom: 100px;
            left: 150px;
            width: 120px;
            height: 120px;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.5s forwards;
        }

        .radar-base {
            width: 80px;
            height: 80px;
            background: #1a1a2e;
            border: 3px solid #00ffff;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
        }

        .radar-dish {
            width: 60px;
            height: 30px;
            background: linear-gradient(135deg, #2a2a4e, #1a1a2e);
            border: 2px solid #00ffff;
            border-radius: 50% 50% 0 0;
            position: absolute;
            top: 10px;
            left: 10px;
            transform-origin: center bottom;
            animation: rotateRadar 3s linear infinite;
        }

        @keyframes rotateRadar {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Aircraft */
        .aircraft {
            position: absolute;
            width: 300px;
            height: 150px;
            opacity: 0;
            animation: fadeIn 1s ease-in 1s forwards;
        }

        .aircraft-body {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 0 15px #00ff88);
        }

        .aircraft.enemy .aircraft-body {
            filter: drop-shadow(0 0 15px #ff4444) sepia(100%) saturate(200%) hue-rotate(0deg) brightness(1.1);
        }

        /* Radar wave (spherical) */
        .radar-wave {
            position: absolute;
            border-radius: 50%;
            border: 2px solid;
            pointer-events: none;
            z-index: 10;
            transform: translate(-50%, -50%);
            box-sizing: border-box;
            overflow: hidden;
        }

        .wave-outgoing {
            border-color: #00ffff;
            box-shadow: 0 0 15px #00ffff, 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .wave-return {
            border-color: #00ff88;
            box-shadow: 0 0 15px #00ff88, 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .wave-return.fake {
            border-color: #ffaa00;
            box-shadow: 0 0 15px #ffaa00, 0 0 30px rgba(255, 170, 0, 0.5);
        }

        /* Internal gradient representing wave energy */
        .wave-fill {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        .wave-outgoing .wave-fill {
            background: radial-gradient(circle, rgba(0, 255, 255, 0.6) 0%, rgba(0, 255, 255, 0.3) 40%, rgba(0, 255, 255, 0.1) 70%, transparent 100%);
        }

        .wave-return .wave-fill {
            background: radial-gradient(circle, rgba(0, 255, 136, 0.6) 0%, rgba(0, 255, 136, 0.3) 40%, rgba(0, 255, 136, 0.1) 70%, transparent 100%);
        }

        .wave-return.fake .wave-fill {
            background: radial-gradient(circle, rgba(255, 170, 0, 0.6) 0%, rgba(255, 170, 0, 0.3) 40%, rgba(255, 170, 0, 0.1) 70%, transparent 100%);
        }

        /* Circular radar screen */
        .radar-screen {
            position: absolute;
            width: 400px;
            height: 400px;
            border: 4px solid #00ff88;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 136, 0.1) 0%, transparent 70%);
            box-shadow: 0 0 30px #00ff88, inset 0 0 50px rgba(0, 255, 136, 0.2);
            bottom: 50px;
            right: 100px;
            opacity: 0;
            animation: fadeIn 1s ease-in 2s forwards;
        }

        .radar-sweep {
            position: absolute;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff88, transparent);
            top: 50%;
            left: 50%;
            transform-origin: left center;
            opacity: 0;
            animation: sweepRadar 3s linear 0.5s infinite;
            box-shadow: 0 0 10px #00ff88;
        }

        @keyframes sweepRadar {
            0% {
                transform: rotate(0deg);
                opacity: 0.8;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: rotate(360deg);
                opacity: 0.8;
            }
        }

        /* Blip on radar screen */
        .radar-blip {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #00ff88;
            border-radius: 50%;
            box-shadow: 0 0 15px #00ff88, 0 0 30px #00ff88;
            opacity: 0;
            transform: translate(-50%, -50%);
        }

        .blip-appear {
            animation: blipAppear 0.5s ease-out forwards;
        }

        @keyframes blipAppear {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .blip-fade-out {
            animation: blipFadeOut 1s ease-out forwards;
        }

        @keyframes blipFadeOut {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        /* Navigation */
        .navigation {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }

        .nav-btn {
            padding: 12px 30px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            text-shadow: 0 0 10px #00ff88;
        }

        .nav-btn:hover {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px #00ff88;
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slide-counter {
            position: fixed;
            top: 30px;
            right: 30px;
            font-size: 1.2em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }


        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Slide-specific aircraft positioning */
        .slide-1 .aircraft {
            top: 200px;
            right: 700px;
        }

        .slide-2 .aircraft {
            top: 200px;
            right: 700px;
        }

        .slide-3 .aircraft {
            top: 100px;
            right: 500px;
        }

        .slide-3 .aircraft.second {
            top: 200px;
            right: 700px;
        }

        .slide-4 .aircraft {
            top: 200px;
            right: 700px;
        }

        .slide-5 .aircraft {
            top: 200px;
            right: 700px;
        }

        /* RGPO animations */
        .blip-moving {
            animation: blipMove 5s ease-out forwards;
        }

        @keyframes blipMove {
            0% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
            50% {
                opacity: 0.9;
            }
            100% {
                /* Final position calculated to stay within display (radius ~190px) */
                transform: translate(46px, -45px);
                opacity: 0.7;
            }
        }

        .blip-trail {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 136, 0.4);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
            animation: trailFade 3s ease-out forwards;
        }

        @keyframes trailFade {
            0% {
                opacity: 0.6;
            }
            100% {
                opacity: 0;
            }
        }

        .blip-real {
            animation: blipPulse 2s ease-in-out infinite;
        }

        @keyframes blipPulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.1);
            }
        }
    </style>
</head>
<body>
    <div class="presentation-container">
        <!-- Slide 1: Introduction -->
        <div class="slide slide-1 active">
            <h1 class="slide-title">Come fa un radar a vedere gli aerei?</h1>
            <h2 class="slide-subtitle">Inganni elettromagnetici e guerra elettronica</h2>
            <div class="slide-content">
                <ul class="bullet-points">
                    <li>Il radar è come un "occhio" che usa onde radio</li>
                    <li>Manda impulsi invisibili e ascolta gli echi</li>
                    <li>Da qui inizia la guerra elettronica…</li>
                </ul>
                <div class="visual-area">
                    <div class="radar-station">
                        <div class="radar-base">
                            <div class="radar-dish"></div>
                        </div>
                    </div>
                    <div class="aircraft">
                        <img src="aircraft-image.png" alt="Aereo" class="aircraft-body">
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 2: Single target -->
        <div class="slide slide-2">
            <h1 class="slide-title">Un bersaglio: un pallino sullo schermo</h1>
            <div class="slide-content">
                <ul class="bullet-points">
                    <li>L'impulso radar parte, rimbalza su un aereo e torna</li>
                    <li>Il radar misura il tempo di ritorno</li>
                    <li>Sul display: un solo pallino luminoso</li>
                </ul>
                <div class="visual-area">
                    <div class="radar-station">
                        <div class="radar-base">
                            <div class="radar-dish"></div>
                        </div>
                    </div>
                    <div class="aircraft">
                        <img src="aircraft-image.png" alt="Aereo" class="aircraft-body">
                    </div>
                    <div class="radar-screen">
                        <div class="radar-sweep"></div>
                        <div class="radar-blip" style="top: 43%; left: 70%;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 3: Two targets -->
        <div class="slide slide-3">
            <h1 class="slide-title">Due aerei, due echi, due pallini</h1>
            <div class="slide-content">
                <ul class="bullet-points">
                    <li>L'onda trasmessa è una sola</li>
                    <li>Ma rimbalza su due aerei vicini</li>
                    <li>Il radar riceve due echi a tempi diversi</li>
                </ul>
                <div class="visual-area">
                    <div class="radar-station">
                        <div class="radar-base">
                            <div class="radar-dish"></div>
                        </div>
                    </div>
                    <div class="aircraft">
                        <img src="aircraft-image.png" alt="Aereo" class="aircraft-body">
                    </div>
                    <div class="aircraft second">
                        <img src="aircraft-image.png" alt="Aereo" class="aircraft-body">
                    </div>
                    <div class="radar-screen">
                        <div class="radar-sweep"></div>
                        <div class="radar-blip" style="top: 38%; left: 80%;"></div>
                        <div class="radar-blip" style="top: 43%; left: 70%;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Radar deception -->
        <div class="slide slide-4">
            <h1 class="slide-title">Inganno radar: un solo aereo che sembra due</h1>
            <div class="slide-content">
                <ul class="bullet-points">
                    <li>L'aereo sa di essere illuminato dal radar</li>
                    <li>Ha un proprio trasmettitore a bordo</li>
                    <li>Imita il segnale riflesso di un "finto vicino"</li>
                </ul>
                <div class="visual-area">
                    <div class="radar-station">
                        <div class="radar-base">
                            <div class="radar-dish"></div>
                        </div>
                    </div>
                    <div class="aircraft enemy">
                        <img src="aircraft-image.png" alt="Aereo" class="aircraft-body">
                    </div>
                    <div class="radar-screen">
                        <div class="radar-sweep"></div>
                        <div class="radar-blip" style="top: 38%; left: 80%;"></div>
                        <div class="radar-blip" style="top: 43%; left: 70%;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: RGPO technique -->
        <div class="slide slide-5">
            <h1 class="slide-title">Inganno "RGPO": far scappare un bersaglio fantasma</h1>
            <div class="slide-content">
                <ul class="bullet-points">
                    <li>Il pallino finto inizia vicino a quello vero</li>
                    <li>Poi, impulso dopo impulso, viene spostato sempre più lontano</li>
                    <li>Il radar può inseguire il fantasma e perdere quello vero</li>
                </ul>
                <div class="visual-area">
                    <div class="radar-station">
                        <div class="radar-base">
                            <div class="radar-dish"></div>
                        </div>
                    </div>
                    <div class="aircraft enemy">
                        <img src="aircraft-image.png" alt="Aereo" class="aircraft-body">
                    </div>
                    <div class="radar-screen">
                        <div class="radar-sweep"></div>
                        <div class="radar-blip blip-moving" style="top: 43%; left: 70%;"></div>
                        <div class="radar-blip" style="top: 43%; left: 70%;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="slide-counter">
        <span id="current-slide">1</span> / 5
    </div>
    <div class="navigation">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()">← Precedente</button>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()">Successiva →</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        // Track animation timeouts to cancel them when changing slides
        let animationTimeouts = [];
        
        // Track if RGPO movement animation has already started for slide 5
        let rgpoMovementStarted = false;
        
        // Track timeout for RGPO animation loop
        let rgpoLoopTimeout = null;

        function showSlide(n) {
            // Cancel all previous animation timeouts
            animationTimeouts.forEach(timeout => clearTimeout(timeout));
            animationTimeouts = [];
            
            // Cancel RGPO loop timeout if present
            if (rgpoLoopTimeout) {
                clearTimeout(rgpoLoopTimeout);
                rgpoLoopTimeout = null;
            }
            
            // Reset ghost blip animation when changing slides
            const oldSlide = slides[currentSlide];
            if (oldSlide) {
                const oldBlips = oldSlide.querySelectorAll('.radar-blip');
                oldBlips.forEach(blip => {
                    blip.classList.remove('blip-moving', 'blip-appear', 'blip-real');
                    // Remove event listeners by cloning
                    const newBlip = blip.cloneNode(true);
                    blip.parentNode.replaceChild(newBlip, blip);
                });
            }
            
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            
            // Reset RGPO movement flag when changing slides
            rgpoMovementStarted = false;
            
            updateNavigation();
            animateSlide(currentSlide);
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                showSlide(currentSlide + 1);
            }
        }

        function previousSlide() {
            if (currentSlide > 0) {
                showSlide(currentSlide - 1);
            }
        }

        function updateNavigation() {
            document.getElementById('current-slide').textContent = currentSlide + 1;
            document.getElementById('prev-btn').disabled = currentSlide === 0;
            document.getElementById('next-btn').disabled = currentSlide === totalSlides - 1;
        }

        // Helper function to restart animation after reflected wave returns
        function restartAnimation(slideIndex) {
            // Small delay before restarting (simulates time between pulses)
            // Only if we're still on the same slide
            if (slideIndex === currentSlide) {
                // For slide 5 (RGPO), use much faster interval (delay = 0)
                // For other slides, maintain 300ms
                const delay = slideIndex === 4 ? 0 : 300;
                const timeout = setTimeout(() => {
                    if (slideIndex === currentSlide) {
                        animateSlide(slideIndex);
                    }
                }, delay);
                animationTimeouts.push(timeout);
            }
        }

        function setupRgpoAnimationLoop(blip) {
            // Function that handles the RGPO animation loop
            function handleAnimationEnd() {
                // Verify we're still on slide 5
                if (currentSlide !== 4) {
                    return;
                }
                
                // Wait 1 second before restarting animation
                rgpoLoopTimeout = setTimeout(() => {
                    // Verify again that we're on slide 5
                    if (currentSlide !== 4) {
                        return;
                    }
                    
                    // Remove class to reset animation
                    blip.classList.remove('blip-moving');
                    
                    // Explicitly reset transform to initial position
                    blip.style.transform = 'translate(-50%, -50%)';
                    
                    // Force reflow to ensure removal is applied
                    void blip.offsetWidth;
                    
                    // Re-add class to restart animation
                    blip.classList.add('blip-moving');
                }, 1000); // 1 second pause
            }
            
            // Add event listener for when animation ends
            blip.addEventListener('animationend', handleAnimationEnd, { once: false });
        }

        function animateSlide(slideIndex) {
            const slide = slides[slideIndex];
            
            // Reset animations
            const waves = slide.querySelectorAll('.radar-wave');
            waves.forEach(w => w.remove());
            
            // Remove any fade-out animations in progress when restarting animation
            const blips = slide.querySelectorAll('.radar-blip');
            blips.forEach(blip => {
                blip.classList.remove('blip-fade-out');
            });
            
            // Remove blips with delay to increase visual persistence
            // For slide 5 (RGPO), reduce persistence to adapt to faster rhythm
            const persistenceDelay = slideIndex === 4 ? 300 : 600; // 300ms for slide 5, 600ms for slides 1-4
            const blipRemovalTimeout = setTimeout(() => {
                // Verify we're still on the same slide before removing blips
                if (slideIndex === currentSlide) {
                    blips.forEach(blip => {
                        // For slide 5 (RGPO), don't apply fade-out to moving blip
                        // if movement animation has already started
                        if (slideIndex === 4 && blip.classList.contains('blip-moving')) {
                            return;
                        }
                        // Apply fade-out animation (like in a classic radar display)
                        blip.classList.add('blip-fade-out');
                        // Remove other classes after fade-out completes (1 second)
                        setTimeout(() => {
                            if (slideIndex === currentSlide) {
                                // For slide 5, don't remove blip-moving if present
                                if (slideIndex === 4 && blip.classList.contains('blip-moving')) {
                                    blip.classList.remove('blip-appear', 'blip-fade-out');
                                } else {
                                    blip.classList.remove('blip-appear', 'blip-moving', 'blip-fade-out');
                                }
                            }
                        }, 1000); // Fade-out animation time
                    });
                }
            }, persistenceDelay);
            animationTimeouts.push(blipRemovalTimeout);

            // Slide-specific animations
            const initialTimeout = setTimeout(() => {
                const visualArea = slide.querySelector('.visual-area');
                const radarStation = slide.querySelector('.radar-station');
                const aircrafts = slide.querySelectorAll('.aircraft');
                
                if (!radarStation || !visualArea) return;
                
                // Calculate radar center position
                const radarRect = radarStation.getBoundingClientRect();
                const visualRect = visualArea.getBoundingClientRect();
                const radarX = radarRect.left - visualRect.left + radarRect.width / 2;
                const radarY = radarRect.top - visualRect.top + radarRect.height / 2;
                
                if (slideIndex === 0) {
                    // Slide 1: pulse from radar to aircraft and back
                    if (aircrafts.length > 0) {
                        const aircraftRect = aircrafts[0].getBoundingClientRect();
                        const aircraftX = aircraftRect.left - visualRect.left + aircraftRect.width / 2;
                        const aircraftY = aircraftRect.top - visualRect.top + aircraftRect.height / 2;
                        
                        // Outgoing wave: fixed center on radar, expands until it touches aircraft
                        createWave(slide, radarX, radarY, aircraftX, aircraftY, 'outgoing', false, () => {
                            // When wave touches target, reflected wave starts
                            // Return wave: fixed center on aircraft, expands toward radar
                            createWave(slide, aircraftX, aircraftY, radarX, radarY, 'return', false, () => {
                                // When reflected wave reaches radar, restart animation
                                restartAnimation(slideIndex);
                            });
                        });
                    }
                } else if (slideIndex === 1) {
                    // Slide 2: pulse and blip
                    if (aircrafts.length > 0) {
                        const aircraftRect = aircrafts[0].getBoundingClientRect();
                        const aircraftX = aircraftRect.left - visualRect.left + aircraftRect.width / 2;
                        const aircraftY = aircraftRect.top - visualRect.top + aircraftRect.height / 2;
                        
                        // Outgoing wave: fixed center on radar
                        createWave(slide, radarX, radarY, aircraftX, aircraftY, 'outgoing', false, () => {
                            // When wave touches target, reflected wave starts
                            // Blip appears when reflected wave reaches radar
                            const blip = slide.querySelector('.radar-blip');
                            createWave(slide, aircraftX, aircraftY, radarX, radarY, 'return', false, () => {
                                // When reflected wave reaches radar, blip appears
                                if (blip) {
                                    blip.classList.add('blip-appear');
                                }
                                // Restart animation after reflected wave returns
                                restartAnimation(slideIndex);
                            });
                        });
                    }
                } else if (slideIndex === 2) {
                    // Slide 3: pulse to two aircraft, two blips
                    if (aircrafts.length >= 2) {
                        const aircraft1Rect = aircrafts[0].getBoundingClientRect();
                        const aircraft1X = aircraft1Rect.left - visualRect.left + aircraft1Rect.width / 2;
                        const aircraft1Y = aircraft1Rect.top - visualRect.top + aircraft1Rect.height / 2;
                        
                        const aircraft2Rect = aircrafts[1].getBoundingClientRect();
                        const aircraft2X = aircraft2Rect.left - visualRect.left + aircraft2Rect.width / 2;
                        const aircraft2Y = aircraft2Rect.top - visualRect.top + aircraft2Rect.height / 2;
                        
                        // Calculate distances to determine which aircraft is hit first
                        const dx1 = aircraft1X - radarX;
                        const dy1 = aircraft1Y - radarY;
                        const distance1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        
                        const dx2 = aircraft2X - radarX;
                        const dy2 = aircraft2Y - radarY;
                        const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        
                        // Use nearest target as reference for callback
                        const nearestTarget = distance1 <= distance2 ? 
                            {x: aircraft1X, y: aircraft1Y, distance: distance1, blipIndex: 0} : 
                            {x: aircraft2X, y: aircraft2Y, distance: distance2, blipIndex: 1};
                        const farthestTarget = distance1 > distance2 ? 
                            {x: aircraft1X, y: aircraft1Y, distance: distance1, blipIndex: 0} : 
                            {x: aircraft2X, y: aircraft2Y, distance: distance2, blipIndex: 1};
                        
                        // Outgoing wave: fixed center on radar, expands and touches both aircraft
                        createWave(slide, radarX, radarY, nearestTarget.x, nearestTarget.y, 'outgoing', false, () => {
                            // When wave touches nearest target, echo starts
                            // Blips appear when reflected waves reach radar
                            const blips = slide.querySelectorAll('.radar-blip');
                            if (blips.length >= 2) {
                                // Track when all reflected waves have returned to restart animation
                                let returnWavesCount = 0;
                                const totalReturnWaves = 2;
                                
                                // When reflected wave from nearest target reaches radar, corresponding blip appears
                                createWave(slide, nearestTarget.x, nearestTarget.y, radarX, radarY, 'return', false, () => {
                                    blips[nearestTarget.blipIndex].classList.add('blip-appear');
                                    returnWavesCount++;
                                    // If all waves have returned, restart animation
                                    if (returnWavesCount === totalReturnWaves) {
                                        restartAnimation(slideIndex);
                                    }
                                });
                                
                                // If there's a farther target, calculate when it's hit
                                if (farthestTarget.distance > nearestTarget.distance) {
                                    // Transmitted wave takes timeDiff longer to reach farther target
                                    const waveSpeed = 1800; // Use same speed as createWave function
                                    const timeDiff = ((farthestTarget.distance - nearestTarget.distance) / waveSpeed) * 1000;
                                    // When transmitted wave touches farther target, reflected wave starts
                                    setTimeout(() => {
                                        // When reflected wave from farther target reaches radar, corresponding blip appears
                                        createWave(slide, farthestTarget.x, farthestTarget.y, radarX, radarY, 'return', false, () => {
                                            blips[farthestTarget.blipIndex].classList.add('blip-appear');
                                            returnWavesCount++;
                                            // If all waves have returned, restart animation
                                            if (returnWavesCount === totalReturnWaves) {
                                                restartAnimation(slideIndex);
                                            }
                                        });
                                    }, timeDiff);
                                } else {
                                    // If at same distance, start immediately
                                    createWave(slide, farthestTarget.x, farthestTarget.y, radarX, radarY, 'return', false, () => {
                                        blips[farthestTarget.blipIndex].classList.add('blip-appear');
                                        returnWavesCount++;
                                        // If all waves have returned, restart animation
                                        if (returnWavesCount === totalReturnWaves) {
                                            restartAnimation(slideIndex);
                                        }
                                    });
                                }
                            }
                        });
                    }
                } else if (slideIndex === 3) {
                    // Slide 4: pulse and two blips (one fake)
                    // Blips have hardcoded positions in HTML (same as slide 3)
                    if (aircrafts.length > 0) {
                        const aircraftRect = aircrafts[0].getBoundingClientRect();
                        const aircraftX = aircraftRect.left - visualRect.left + aircraftRect.width / 2;
                        const aircraftY = aircraftRect.top - visualRect.top + aircraftRect.height / 2;
                        
                        // Outgoing wave: fixed center on radar
                        createWave(slide, radarX, radarY, aircraftX, aircraftY, 'outgoing', false, () => {
                            // When wave touches target, real reflected wave starts
                            // Blips appear when reflected waves reach radar
                            const blips = slide.querySelectorAll('.radar-blip');
                            if (blips.length >= 2) {
                                // Track when all reflected waves have returned to restart animation
                                let returnWavesCount = 0;
                                const totalReturnWaves = 2;
                                
                                // When real reflected wave reaches radar, blip farther from center appears (blips[1])
                                createWave(slide, aircraftX, aircraftY, radarX, radarY, 'return', false, () => {
                                    blips[1].classList.add('blip-appear');
                                    returnWavesCount++;
                                    // If all waves have returned, restart animation
                                    if (returnWavesCount === totalReturnWaves) {
                                        restartAnimation(slideIndex);
                                    }
                                });
                                
                                // Shortly after, fake echo also starts (simulates deception system)
                                setTimeout(() => {
                                    // When fake reflected wave reaches radar, blip closer to center appears (blips[0])
                                    createWave(slide, aircraftX, aircraftY, radarX, radarY, 'return', true, () => {
                                        blips[0].classList.add('blip-appear');
                                        returnWavesCount++;
                                        // If all waves have returned, restart animation
                                        if (returnWavesCount === totalReturnWaves) {
                                            restartAnimation(slideIndex);
                                        }
                                    });
                                }, 200);
                            }
                        });
                    }
                } else if (slideIndex === 4) {
                    // Slide 5: RGPO - moving blip
                    // Blips have hardcoded positions in HTML (same as slides 3 and 4)
                    if (aircrafts.length > 0) {
                        const aircraftRect = aircrafts[0].getBoundingClientRect();
                        const aircraftX = aircraftRect.left - visualRect.left + aircraftRect.width / 2;
                        const aircraftY = aircraftRect.top - visualRect.top + aircraftRect.height / 2;
                        
                        // Calculate distance to determine propagation time
                        const dx = aircraftX - radarX;
                        const dy = aircraftY - radarY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Wave speed for slide 5 (faster for more frequent pulses)
                        const waveSpeed = 5000; // pixels per second (increased for faster rhythm)
                        
                        // Outgoing wave: fixed center on radar (uses custom speed)
                        createWave(slide, radarX, radarY, aircraftX, aircraftY, 'outgoing', false, () => {
                            // When wave touches target, real reflected wave starts
                            const blips = slide.querySelectorAll('.radar-blip');
                            if (blips.length >= 2) {
                                // Track when all reflected waves have returned to restart animation
                                let returnWavesCount = 0;
                                const totalReturnWaves = 2;
                                
                                // When real reflected wave reaches radar, real blip appears (uses custom speed)
                                createWave(slide, aircraftX, aircraftY, radarX, radarY, 'return', false, () => {
                                    // Real blip (first) - appears when real wave arrives
                                    blips[0].classList.add('blip-appear', 'blip-real');
                                    returnWavesCount++;
                                    
                                    // If all waves have returned, restart animation
                                    if (returnWavesCount === totalReturnWaves) {
                                        restartAnimation(slideIndex);
                                    }
                                }, waveSpeed);
                                
                                // Fake wave starts from aircraft when illuminated (simulates deception system)
                                // Fake wave has slight delay to simulate system processing time
                                setTimeout(() => {
                                    // When fake wave reaches radar, fake blip appears (uses custom speed)
                                    createWave(slide, aircraftX, aircraftY, radarX, radarY, 'return', true, () => {
                                        // Fake blip (second) - appears when fake wave arrives (synchronized)
                                        // Don't re-add blip-appear if movement animation is already in progress
                                        if (!blips[1].classList.contains('blip-moving')) {
                                            blips[1].classList.add('blip-appear');
                                        }
                                        returnWavesCount++;
                                        
                                        // Start RGPO movement only once, on first pulse
                                        if (!rgpoMovementStarted) {
                                            rgpoMovementStarted = true;
                                            // After brief delay, start RGPO movement
                                            setTimeout(() => {
                                                blips[1].classList.add('blip-moving');
                                                // Configure animation loop (1 sec pause and restart)
                                                setupRgpoAnimationLoop(blips[1]);
                                                // Create movement trail
                                                createBlipTrail(slide, blips[1]);
                                            }, 200);
                                        }
                                        
                                        // If all waves have returned, restart animation
                                        if (returnWavesCount === totalReturnWaves) {
                                            restartAnimation(slideIndex);
                                        }
                                    }, waveSpeed);
                                }, 50); // Small delay to simulate deception system reaction time
                            }
                        }, waveSpeed);
                    }
                }
            }, 500);
            animationTimeouts.push(initialTimeout);
        }

        function createWave(slide, centerX, centerY, targetX, targetY, type, isFake = false, onReachTarget = null, customWaveSpeed = null) {
            const visualArea = slide.querySelector('.visual-area');
            if (!visualArea) return;
            
            const dx = targetX - centerX;
            const dy = targetY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Increased speed to give idea of light speed
            // If not specified, use default speed
            const waveSpeed = customWaveSpeed || 1800; // pixels per second (default: 1800)
            
            // Create a single wave
            const wave = document.createElement('div');
            wave.className = `radar-wave wave-${type}`;
            if (isFake && type === 'return') {
                wave.classList.add('fake');
            }
            
            // Create internal gradient
            const waveFill = document.createElement('div');
            waveFill.className = 'wave-fill';
            wave.appendChild(waveFill);
            
            // Center remains fixed on source
            wave.style.left = centerX + 'px';
            wave.style.top = centerY + 'px';
            const startSize = 20;
            const startRadius = startSize / 2;
            wave.style.width = startSize + 'px';
            wave.style.height = startSize + 'px';
            wave.style.opacity = '1';
            
            visualArea.appendChild(wave);
            
            // Animate wave expansion (fixed center, expands radially)
            let startTime = Date.now();
            const maxRadius = distance * 1.5; // Wave expands well beyond target
            let targetReached = false;
            
            function animate() {
                const elapsed = (Date.now() - startTime) / 1000;
                
                // Center always remains fixed
                wave.style.left = centerX + 'px';
                wave.style.top = centerY + 'px';
                
                // Linear radius growth: r(t) = r0 + v*t (constant velocity)
                const currentRadius = startRadius + waveSpeed * elapsed;
                const currentSize = currentRadius * 2;
                const progress = Math.min((currentRadius - startRadius) / (maxRadius - startRadius), 1);
                
                wave.style.width = currentSize + 'px';
                wave.style.height = currentSize + 'px';
                
                // Check if wave has reached target
                if (!targetReached && onReachTarget && currentRadius >= distance) {
                    targetReached = true;
                    onReachTarget();
                }
                
                // Border opacity: fades as it expands
                const borderOpacity = 1 - progress * 0.7;
                wave.style.opacity = Math.max(0, borderOpacity);
                
                // Internal gradient opacity: disappears quickly
                // Gradient should only be visible when wave is small
                const fillOpacity = Math.max(0, 1 - progress * 2.5); // Disappears much faster
                waveFill.style.opacity = fillOpacity;
                
                // Fixed transformation: only translation to center wave
                wave.style.transform = `translate(-50%, -50%)`;
                
                // Continue animation until radius exceeds maximum
                if (currentRadius < maxRadius) {
                    requestAnimationFrame(animate);
                } else {
                    wave.remove();
                }
            }
            
            requestAnimationFrame(animate);
        }

        function createBlipTrail(slide, blip) {
            const screen = slide.querySelector('.radar-screen');
            if (!screen) return;
            
            const screenRect = screen.getBoundingClientRect();
            const blipRect = blip.getBoundingClientRect();
            
            const startX = blipRect.left - screenRect.left + blipRect.width / 2;
            const startY = blipRect.top - screenRect.top + blipRect.height / 2;
            
            // Create some trail points
            // Updated path: 46px horizontal, -45px vertical (instead of 180px, -120px)
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const trail = document.createElement('div');
                    trail.className = 'blip-trail';
                    const offsetX = (i * 9.2); // 46px / 5 ≈ 9.2px per point
                    const offsetY = -(i * 9); // 45px / 5 = 9px per point
                    trail.style.left = (startX + offsetX) + 'px';
                    trail.style.top = (startY + offsetY) + 'px';
                    screen.appendChild(trail);
                    
                    setTimeout(() => {
                        trail.remove();
                    }, 3000);
                }, i * 400);
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                previousSlide();
            }
        });

        // Initialize
        updateNavigation();
        animateSlide(0);
    </script>
</body>
</html>
